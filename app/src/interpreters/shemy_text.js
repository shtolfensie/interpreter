const text = 'const tokenize = program => {\r\n  \/\/ adds whitespace around brackets, strips all ws except space, splits input string based on spaces\r\n  return program\r\n    .replace(\/(\\(|\\))\/g, \" $1 \")\r\n    .replace(\/\\r*\\n*\\t*\/g, \"\")\r\n    .split(\" \")\r\n    .filter(s => s.length !== 0);\r\n};\r\n\r\nconst parse = tokens => {\r\n  \/\/ checks for an empty imput string\r\n  if (tokens.length === 0) {\r\n    console.error(\"No tokens to parse\");\r\n    return 1;\r\n  }\r\n\r\n  \/\/ checks for incorrect EOF\r\n  if (tokens[0] === \")\") {\r\n    console.error(\"Unexpected end of file\");\r\n    return 2;\r\n  }\r\n\r\n  \/\/ start a new block\r\n  if (tokens[0] === \"(\") {\r\n    tokens.shift(); \/\/ remove the starting (\r\n    let nextTokens = []; \/\/ create an array for storing a new block\r\n    \/\/ until we reach the end of the block\r\n    while (tokens[0] !== \")\" && tokens.length) {\r\n      nextTokens.push(parse(tokens)); \/\/ parse the block and push it to the array\r\n      tokens.shift(); \/\/ remove the token we just parsed from the start\r\n    }\r\n    tokens.pop(); \/\/ remove one closing ) from the end\r\n\r\n    return nextTokens; \/\/ return the block\r\n  } else {\r\n    return atom(tokens[0]); \/\/ if nothing else, it is an atom, return it\r\n  }\r\n};\r\n\r\n\/\/ turns numbers into numbers (int, float), everything else is a string\r\nconst atom = token => {\r\n  \/\/ return \/(\\d+( \\.\\d+)?)\/.test(token) ? +token : String(token);\r\n  let atom = \/[^\\d.]\/.test(token) ? String(token) : +token; \/\/ 1.4.60 this breaks it!!!!\r\n  if ((typeof atom !== \"number\") && atom.length > 1 && atom.slice(0, 1) === \'-\' && !(\/[^\\d.]\/.test(atom.slice(1)))) atom = parseInt(atom); \/\/ find negative numbers\r\n  return atom;\r\n};\r\n\r\nconst environment = ({ params, args, outer }) => { \/\/ create an environment object\r\n\r\n  let env = {};\r\n  outer = outer || {}; \/\/ if an outer env is not supplied, set it to an empty object\r\n\r\n\r\n  const find = (variable) => {\r\n    if (env.hasOwnProperty(variable)) { \/\/ if env has a variable, return it\r\n      return env;\r\n    }\r\n    else { \/\/ otherwise, try looking for it in the outer env\r\n      return outer.find(variable);\r\n    }\r\n  }\r\n\r\n  for (let i = 0; i < params.length; i++) {\r\n    env[params[i]] = args[i];\r\n  }\r\n\r\n  env.find = find;\r\n\r\n  return env;\r\n}\r\n\r\n\/\/ create the global environment\r\nconst createGlobals = (env) => {\r\n\r\n  \/\/ create a list of all the functions in Math and add them to the env\r\n  const jsMathFunctions = [\r\n    \"abs\", \"acos\", \"acosh\", \"asin\",\r\n    \"asinh\", \"atan\", \"atan2\", \"atanh\",\r\n    \"cbrt\", \"ceil\", \"clz32\", \"cos\",\r\n    \"cosh\", \"exp\", \"expm1\", \"floor\",\r\n    \"fround\", \"hypot\", \"imul\", \"log\",\r\n    \"log10\", \"log1p\", \"log2\", \"max\",\r\n    \"min\", \"pow\", \"random\", \"round\",\r\n    \"sign\", \"sin\", \"sinh\", \"sqrt\",\r\n    \"tan\", \"tanh\", \"trunc\"]\r\n\r\n  jsMathFunctions.forEach(fun => env[fun] = Math[fun]);\r\n\r\n  \/\/ add all basic math functions, that are not in the Math object and other basic functions\r\n  env[\'+\'] = (a, b) => a + b;\r\n  env[\'-\'] = (a, b) => a - b;\r\n  env[\'*\'] = (a, b) => a * b;\r\n  env[\'\/\'] = (a, b) => a \/ b;\r\n  env[\'>\'] = (a, b) => a > b;\r\n  env[\'<\'] = (a, b) => a < b;\r\n  env[\'>=\'] = (a, b) => a >= b;\r\n  env[\'<=\'] = (a, b) => a <= b;\r\n  env[\'=\'] = (a, b) => a === b;\r\n  env[\'equal?\'] = (a, b) => a === b;\r\n  env[\'not\'] = (a) => !a;\r\n  env[\'and\'] = (a, b) => a && b;\r\n  env[\'or\'] = (a, b) => a || b;\r\n\r\n  \/\/ add basic math constants\r\n  env[\'PI\'] = Math.PI;\r\n  env[\"E\"] = Math.E\r\n  env[\"LN10\"] = Math.LN10\r\n  env[\"LN2\"] = Math.LN2\r\n  env[\"LOG10E\"] = Math.LOG10E\r\n  env[\"LOG2E\"] = Math.LOG2E\r\n  env[\"PI\"] = Math.PI\r\n  env[\"SQRT1_2\"] = Math.SQRT1_2\r\n  env[\"SQRT2\"] = Math.SQRT2\r\n\r\n  return env;\r\n}\r\n\r\nlet globalEnv = createGlobals(environment({ params: [], specs: [], outer: null }))\r\n\r\n\/\/ console.log(globalEnv[\'+\'](105, 47));\r\n\r\n\r\n\/\/ evaluate AST returned from parser()\r\n\/\/ expects an AST node and the current env that is to be used for the evaluation\r\nconst evaluate = (ast, env) => {\r\n  env = env || globalEnv;\r\n  if (typeof ast === \'string\') { \/\/ if the entire AST node is a string, it is a variable\r\n    return env.find(ast)[ast]; \/\/ if there is a variable by this name in any env, this env gets returned and then the value of the variable is returned\r\n  }\r\n  else if (typeof ast === \"number\") { \/\/ it the entire AST node is a constant number, return it\r\n    return ast;\r\n  }\r\n  else if (ast[0] === \'define\') { \/\/ the first node of the AST is define\r\n    env[ast[1]] = evaluate(ast[2], env); \/\/ evaluate the third element of the AST node and save it into the env under the second element\r\n  }\r\n  else if (ast[0] === \'begin\') {\r\n    let res;\r\n    for (let i = 1; i < ast.length; i++) {\r\n      res = evaluate(ast[i], env);\r\n    }\r\n    return res;\r\n  }\r\n  else {\r\n    let args = [];\r\n    for (let i = 0; i < ast.length; i++) {\r\n      args[i] = evaluate(ast[i], env);\r\n    }\r\n    let procedure = args.shift();\r\n\r\n    return procedure.apply(null, args);\r\n  }\r\n}\r\n\r\n\/\/ let ast = parse(tokenize(\"(begin (define r 1) (define t (- 5 2)) (+ r (* t 2)))\"));\r\n\/\/ let ast = parse(tokenize(\"(hypot 3 4)\"));\r\n\/\/ let ast = parse(tokenize(\"(begin (+ -456 -30))\"));\r\n\/\/ let ast = parse(tokenize(\"(begin (define r 30) (define pi 3.14159) (* pi (* r r)))\"));\r\n\/\/ let ast = parse(tokenize(\"(begin (define r 30) (* PI (* r r)))\"));\r\nlet ast = parse(tokenize(\"(abs -4)\"));\r\nconsole.log(ast);\r\n\r\nlet res = evaluate(ast);\r\nconsole.log(res);\r\n\r\n\r\n\/\/ console.log(\r\n\/\/   \/\/ JSON.stringify(parse(tokenize(\" ( begin (  define r 10) (* pi ( * r r )))\")))\r\n\/\/   JSON.stringify(parse(tokenize(\"(+ 2 3)\")))\r\n\/\/   \/\/ JSON.stringify(\r\n\/\/   \/\/   parse(\r\n\/\/   \/\/     tokenize(`\r\n\/\/   \/\/ (begin \r\n\/\/   \/\/   (define r 1.460)\r\n\/\/   \/\/   (* pi (* r r)))`)\r\n\/\/   \/\/   )\r\n\/\/   \/\/ )\r\n\/\/   \/\/ JSON.stringify(parse(tokenize(\"\")))\r\n\/\/ );\r\n\r\nconst interpreter_schemy = (program) => {\r\n  let ast = parse(tokenize(program));\r\n  return { ast, output: evaluate(ast) }\r\n\r\n}\r\n\r\nexport default interpreter_schemy;'

export default text;